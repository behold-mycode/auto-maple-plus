"""
A module that handles screen capture and image processing for the bot.
"""

import cv2
import mss
import numpy as np
import threading
import time
import os
import platform
from src.common import config, utils

# Load template files with error handling
def load_template_safe(path):
    """Load a template file with error handling."""
    if os.path.exists(path):
        template = cv2.imread(path, 0)  # Load as grayscale
        if template is not None:
            return template.astype(np.uint8)
    print(f"[WARN] Failed to load template: {path}")
    return None

# A rune's symbol on the minimap (direct template matching)
RUNE_TEMPLATE = load_template_safe('assets/rune_template.png')

# Other players' symbols on the minimap (direct template matching)
OTHER_TEMPLATE = load_template_safe('assets/other_template.png')

# The Elite Boss's warning sign
ELITE_TEMPLATE = load_template_safe('assets/elite_template.jpg')

# Rune CD Templates
RUNE_CD1_TEMPLATE = load_template_safe('assets/runeCD.png')
RUNE_CD2_TEMPLATE = load_template_safe('assets/runeCD2.png')

# The top-left and bottom-right corners of the minimap
MM_TL_TEMPLATE = load_template_safe('assets/minimap_tl_template.png')
MM_BR_TEMPLATE = load_template_safe('assets/minimap_br_template.png')

# Set default dimensions if templates failed to load
if MM_TL_TEMPLATE is not None and MM_BR_TEMPLATE is not None:
    MMT_HEIGHT = max(MM_TL_TEMPLATE.shape[0], MM_BR_TEMPLATE.shape[0])
    MMT_WIDTH = max(MM_TL_TEMPLATE.shape[1], MM_BR_TEMPLATE.shape[1])
else:
    MMT_HEIGHT = 50  # Default fallback
    MMT_WIDTH = 50   # Default fallback

# The player's symbol on the minimap
PLAYER_TEMPLATE = load_template_safe('assets/player_template.png')
if PLAYER_TEMPLATE is not None:
    PT_HEIGHT, PT_WIDTH = PLAYER_TEMPLATE.shape
else:
    PT_HEIGHT, PT_WIDTH = 10, 10  # Default fallback

# Minimap border constants
MINIMAP_TOP_BORDER = 2
MINIMAP_BOTTOM_BORDER = 2


class Capture:
    """
    A class that tracks player position and various in-game events. It constantly updates
    the config module with information regarding these events. It also annotates and
    displays the minimap in a pop-up window.
    """

    def __init__(self):
        """Initializes this Capture object's main thread."""

        config.capture = self

        self.frame = None
        self.minimap = {}
        self.minimap_ratio = 1
        self.minimap_sample = None
        self.sct = None
        self.window = {
            'left': 0,
            'top': 0,
            'width': 1366,
            'height': 768
        }

        self.ready = False
        self.calibrated = False
        self.debug_mode = True  # Enable debug mode by default
        self.thread = threading.Thread(target=self._main)
        self.thread.daemon = True

    def start(self):
        """Starts this Capture's thread."""

        print('\n[~] Started video capture')
        self.thread.start()

    def _load_saved_window_config(self):
        """Load saved window configuration from file."""
        try:
            import json
            import os
            
            config_file = "window_config.json"
            if os.path.exists(config_file):
                with open(config_file, 'r') as f:
                    config_data = json.load(f)
                    # Validate the config
                    if all(key in config_data for key in ['left', 'top', 'width', 'height']):
                        return config_data
        except Exception as e:
            print(f"[WARN] Failed to load saved window config: {e}")
        return None
    
    def _load_manual_minimap_config(self):
        """Load manual minimap configuration from file."""
        try:
            import json
            import os
            
            config_file = "minimap_config.json"
            if os.path.exists(config_file):
                with open(config_file, 'r') as f:
                    config_data = json.load(f)
                    # Validate the config
                    if all(key in config_data for key in ['mm_left', 'mm_top', 'mm_right', 'mm_bottom']):
                        return config_data
        except Exception as e:
            print(f"[WARN] Failed to load manual minimap config: {e}")
        return None

    def _find_maple_window(self):
        """Cross-platform window finding.

        Tries, in order:
        1. Previously cached window rectangle (to avoid repeated searches).
        2. Saved configuration generated by the window selector helper.
        3. Manual settings toggled by the user via settings.py.
        4. OS-specific window enumeration (macOS → Quartz, Windows → Win32 API).
        5. Template-based fallback (TODO).
        6. Hard-coded default (0,0,1366,768).
        """

        # 1. Return cached rectangle if we have already found one and it is plausible
        if getattr(self, "_cached_window_rect", None):
            return self._cached_window_rect

        # Check for saved window configuration FIRST (from automation tools)
        saved_config = self._load_saved_window_config()
        if saved_config:
            print(f"[INFO] Using saved window config: {saved_config}")
            rect = (
                saved_config['left'],
                saved_config['top'],
                saved_config['left'] + saved_config['width'],
                saved_config['top'] + saved_config['height']
            )
            self._cached_window_rect = rect
            return rect
        
        # Check if manual window position is enabled (fallback)
        settings_obj = getattr(config, 'settings', None)
        if settings_obj is not None and getattr(settings_obj, 'use_manual_window_position', False):
            print(f"[INFO] Using manual window position: ({settings_obj.maple_window_left}, {settings_obj.maple_window_top}, {settings_obj.maple_window_width}, {settings_obj.maple_window_height})")
            rect = (
                settings_obj.maple_window_left,
                settings_obj.maple_window_top,
                settings_obj.maple_window_left + settings_obj.maple_window_width,
                settings_obj.maple_window_top + settings_obj.maple_window_height
            )
            self._cached_window_rect = rect
            return rect
        
        # Try template-based detection (works on all platforms)
        window_rect = self._find_maple_window_by_template()
        if window_rect:
            self._cached_window_rect = window_rect
            return window_rect
        
        # Platform-specific fallback
        system_name = platform.system()
        if system_name == "Windows":
            try:
                import ctypes
                from ctypes import wintypes
                user32 = ctypes.windll.user32
                handle = user32.FindWindowW(None, 'MapleStory')
                if handle:
                    rect = wintypes.RECT()
                    user32.GetWindowRect(handle, ctypes.pointer(rect))
                    rect = (rect.left, rect.top, rect.right, rect.bottom)
                    rect = tuple(max(0, x) for x in rect)
                    self._cached_window_rect = rect
                    return rect
            except Exception as e:
                print(f"[WARN] Windows API detection failed: {e}")
        elif system_name == "Darwin":
            # Use Quartz window services to locate MapleStory window
            try:
                from Quartz import CGWindowListCopyWindowInfo, kCGWindowListOptionOnScreenOnly, kCGNullWindowID
                window_list = CGWindowListCopyWindowInfo(kCGWindowListOptionOnScreenOnly, kCGNullWindowID)
                for window in window_list:
                    name = window.get('kCGWindowName', '') or ''
                    owner_name = window.get('kCGWindowOwnerName', '') or ''
                    if 'MapleStory' in name or 'MapleStory' in owner_name:
                        bounds = window['kCGWindowBounds']
                        x = int(bounds.get('X', 0))
                        y = int(bounds.get('Y', 0))
                        width = int(bounds.get('Width', 0))
                        height = int(bounds.get('Height', 0))
                        if width > 0 and height > 0:
                            rect = (x, y, x + width, y + height)
                            self._cached_window_rect = rect
                            print(f"[INFO] macOS Quartz detected MapleStory window: {rect}")
                            return rect
            except (ImportError, Exception) as e:
                print(f"[WARN] macOS Quartz window detection failed: {e}")
        
        # Default fallback
        print("[INFO] Using default window coordinates")
        rect = (0, 0, 1366, 768)
        self._cached_window_rect = rect
        return rect

    def _find_maple_window_by_template(self):
        """Template-based window detection as fallback."""
        try:
            # This would use template matching to find the MapleStory window
            # For now, return None to use other methods
            return None
        except Exception as e:
            print(f"[WARN] Template-based window detection failed: {e}")
            return None

    def screenshot(self):
        """Takes a screenshot of the MapleStory window."""

        try:
            with mss.mss() as sct:
                monitor = {
                    'left': self.window['left'],
                    'top': self.window['top'],
                    'width': self.window['width'],
                    'height': self.window['height']
                }
                screenshot = sct.grab(monitor)
                frame = np.array(screenshot)
                frame = cv2.cvtColor(frame, cv2.COLOR_BGRA2BGR)
                return frame
        except Exception as e:
            print(f"[WARN] Screenshot failed: {e}")
            return None

    def _calibrate_minimap(self):
        """Calibrates the minimap by finding its boundaries."""

        try:
            # Check for manual minimap configuration first
            manual_config = self._load_manual_minimap_config()
            if manual_config:
                print(f"[INFO] Using manual minimap config: {manual_config}")
                self.minimap_config = manual_config
                
                # Calculate minimap coordinates relative to window
                mm_tl = (
                    manual_config['mm_left'] - self.window['left'],
                    manual_config['mm_top'] - self.window['top']
                )
                mm_br = (
                    manual_config['mm_right'] - self.window['left'],
                    manual_config['mm_bottom'] - self.window['top']
                )
                
                # Validate coordinates are within window bounds
                if (0 <= mm_tl[0] < self.window['width'] and 
                    0 <= mm_tl[1] < self.window['height'] and
                    0 <= mm_br[0] <= self.window['width'] and 
                    0 <= mm_br[1] <= self.window['height'] and
                    mm_br[0] > mm_tl[0] and mm_br[1] > mm_tl[1]):
                    
                    self.minimap_ratio = (mm_br[0] - mm_tl[0]) / (mm_br[1] - mm_tl[1])
                    if self.frame is not None:
                        # Extract minimap from color frame for display
                        self.minimap_sample = self.frame[mm_tl[1]:mm_br[1], mm_tl[0]:mm_br[0]]
                        # Create grayscale version for template matching
                        self.minimap_gray = cv2.cvtColor(self.minimap_sample, cv2.COLOR_BGR2GRAY)
                        self.calibrated = True
                        print(f"[INFO] Minimap calibrated using manual config: TL={mm_tl}, BR={mm_br}, ratio={self.minimap_ratio:.2f}")
                        return True
                    else:
                        print("[WARN] No frame available for minimap calibration")
                        return False
                else:
                    print("[WARN] Manual minimap coordinates outside window bounds")
                    return False
            else:
                print("[WARN] No manual minimap config found")
                return False
                
        except Exception as e:
            print(f"[WARN] Minimap calibration failed: {e}")
            return False

    def _detect_player(self, minimap):
        """Detect player position on the minimap."""
        
        try:
            # Ensure minimap is valid before processing
            if minimap is None or minimap.size == 0:
                print("[WARN] Invalid minimap data for player detection")
                return False
                
            # Ensure minimap is grayscale and uint8
            if len(minimap.shape) == 3:
                minimap = cv2.cvtColor(minimap, cv2.COLOR_BGR2GRAY)
            if minimap.dtype != np.uint8:
                minimap = minimap.astype(np.uint8)
                
            # Find player using template matching if available
            if PLAYER_TEMPLATE is not None:
                try:
                    # Use multi-scale matching like the working test script
                    player_matches = utils.multi_scale_match(minimap, PLAYER_TEMPLATE, threshold=0.35, scale_range=(0.9, 1.1), scale_steps=3)
                    
                    if player_matches:
                        # Filter out low confidence matches and duplicates
                        high_confidence_matches = [m for m in player_matches if m[3] > 0.5]
                        if high_confidence_matches:
                            player_x, player_y, scale, confidence = high_confidence_matches[0]
                            
                            # Adjust position to center of player icon
                            if PLAYER_TEMPLATE is not None:
                                template_width = int(PLAYER_TEMPLATE.shape[1] * scale)
                                template_height = int(PLAYER_TEMPLATE.shape[0] * scale)
                                player_x += template_width // 2
                                player_y += template_height // 2
                            
                            # Only log occasionally to avoid spam
                            if hasattr(self, '_debug_counter') and self._debug_counter % 100 == 0:
                                print(f"[DEBUG] Player detected at ({player_x}, {player_y}) with scale {scale:.2f}, confidence {confidence:.3f}")
                            
                            config.player_pos = utils.convert_to_relative((player_x, player_y), minimap)
                            return True
                    else:
                        # Try single-scale with lower thresholds as fallback
                        thresholds = [0.25, 0.3, 0.35]
                        player = None
                        
                        for threshold in thresholds:
                            player = utils.multi_match(minimap, PLAYER_TEMPLATE, threshold=threshold)
                            if player:
                                # Only log occasionally to avoid spam
                                if hasattr(self, '_debug_counter') and self._debug_counter % 100 == 0:
                                    print(f"[DEBUG] Player detected with single-scale threshold {threshold}")
                                break
                        
                        if player:
                            config.player_pos = utils.convert_to_relative(player[0], minimap)
                            return True
                        else:
                            print("[WARN] Could not detect player position with template (tried multi-scale and single-scale)")
                            # Fallback to center of minimap
                            minimap_height, minimap_width = minimap.shape[:2]
                            center_pos = (minimap_width // 2, minimap_height // 2)
                            config.player_pos = utils.convert_to_relative(center_pos, minimap)
                            print("[INFO] Using minimap center as player position")
                            return True
                except Exception as template_error:
                    print(f"[WARN] Template matching failed: {template_error}")
                    # Fallback to center of minimap
                    minimap_height, minimap_width = minimap.shape[:2]
                    center_pos = (minimap_width // 2, minimap_height // 2)
                    config.player_pos = utils.convert_to_relative(center_pos, minimap)
                    print("[INFO] Using minimap center as player position (template error)")
                    return True
            else:
                # No template available, use center of minimap
                minimap_height, minimap_width = minimap.shape[:2]
                center_pos = (minimap_width // 2, minimap_height // 2)
                config.player_pos = utils.convert_to_relative(center_pos, minimap)
                print("[INFO] No player template available, using minimap center")
                return True
                
        except Exception as e:
            print(f"[WARN] Player detection failed: {e}")
            return False

    def _detect_others(self, minimap, exclude_rune=False):
        """Detect other players on the minimap."""
        
        try:
            # Ensure minimap is valid before processing
            if minimap is None or minimap.size == 0:
                config.others_pos = []
                return
                
            # Ensure minimap is grayscale and uint8
            if len(minimap.shape) == 3:
                minimap = cv2.cvtColor(minimap, cv2.COLOR_BGR2GRAY)
            if minimap.dtype != np.uint8:
                minimap = minimap.astype(np.uint8)
                
            if OTHER_TEMPLATE is not None:
                try:
                    # Use multi-scale matching with higher threshold to reduce false positives
                    others_matches = utils.multi_scale_match(minimap, OTHER_TEMPLATE, threshold=0.95, scale_range=(0.9, 1.1), scale_steps=3)
                    
                    if others_matches:
                        # Filter by confidence and apply non-maximum suppression
                        high_confidence_matches = [m for m in others_matches if m[3] > 0.8]
                        
                        if high_confidence_matches:
                            # Apply non-maximum suppression to remove overlapping detections
                            filtered_matches = self._apply_nms(high_confidence_matches, iou_threshold=0.3)
                            
                            # Limit to reasonable number of other players (max 3)
                            filtered_matches = filtered_matches[:3]
                            
                            # Adjust positions to center of other player icons
                            centered_others = []
                            for match in filtered_matches:
                                x, y, scale, confidence = match
                                if OTHER_TEMPLATE is not None:
                                    template_width = int(OTHER_TEMPLATE.shape[1] * scale)
                                    template_height = int(OTHER_TEMPLATE.shape[0] * scale)
                                    x += template_width // 2
                                    y += template_height // 2
                                centered_others.append((x, y))
                            
                            # Filter out rune positions if rune is active
                            if exclude_rune and hasattr(self, 'minimap') and 'rune_pos' in self.minimap:
                                rune_pos = self.minimap['rune_pos']
                                if rune_pos is not None:
                                    # Convert rune position to minimap coordinates for comparison
                                    rune_x, rune_y = utils.convert_to_absolute(rune_pos, minimap)
                                    filtered_others = []
                                    for pos in centered_others:
                                        # Check distance to rune position
                                        distance = ((pos[0] - rune_x) ** 2 + (pos[1] - rune_y) ** 2) ** 0.5
                                        if distance > 20:  # Minimum distance threshold
                                            filtered_others.append(pos)
                                    centered_others = filtered_others
                            
                            config.others_pos = [utils.convert_to_relative(pos, minimap) for pos in centered_others]
                            
                            # Only log when other players are detected (not every frame)
                            if hasattr(self, '_last_others_count'):
                                current_others = len(config.others_pos)
                                if current_others != self._last_others_count:
                                    if current_others > self._last_others_count:
                                        print(f"[INFO] 👥 Other player joined (Total: {current_others})")
                                    else:
                                        print(f"[INFO] 👥 Other player left (Total: {current_others})")
                            self._last_others_count = len(config.others_pos)
                        else:
                            config.others_pos = []
                    else:
                        config.others_pos = []
                        
                except Exception as template_error:
                    print(f"[WARN] Others template matching failed: {template_error}")
                    config.others_pos = []
            else:
                config.others_pos = []
                
        except Exception as e:
            print(f"[WARN] Others detection failed: {e}")
            config.others_pos = []

    def _apply_nms(self, matches, iou_threshold=0.3):
        """
        Apply Non-Maximum Suppression to filter overlapping detections.
        
        Args:
            matches: List of tuples (x, y, scale, confidence)
            iou_threshold: IoU threshold for suppression
            
        Returns:
            List of filtered matches
        """
        if not matches:
            return []
            
        # Sort matches by confidence (highest first)
        matches = sorted(matches, key=lambda x: x[3], reverse=True)
        
        # Convert matches to bounding boxes for IoU calculation
        boxes = []
        for x, y, scale, conf in matches:
            if OTHER_TEMPLATE is not None:
                w = int(OTHER_TEMPLATE.shape[1] * scale)
                h = int(OTHER_TEMPLATE.shape[0] * scale)
                # Convert center coordinates to bounding box
                x1, y1 = x - w//2, y - h//2
                x2, y2 = x + w//2, y + h//2
                boxes.append((x1, y1, x2, y2, conf))
        
        # Apply NMS
        keep_indices = []
        for i in range(len(boxes)):
            keep = True
            for j in keep_indices:
                if self._calculate_iou(boxes[i][:4], boxes[j][:4]) > iou_threshold:
                    keep = False
                    break
            if keep:
                keep_indices.append(i)
        
        # Return filtered matches
        return [matches[i] for i in keep_indices]
    
    def _calculate_iou(self, box1, box2):
        """
        Calculate Intersection over Union between two bounding boxes.
        
        Args:
            box1: (x1, y1, x2, y2)
            box2: (x1, y1, x2, y2)
            
        Returns:
            IoU value
        """
        x1_1, y1_1, x2_1, y2_1 = box1
        x1_2, y1_2, x2_2, y2_2 = box2
        
        # Calculate intersection
        x1_i = max(x1_1, x1_2)
        y1_i = max(y1_1, y1_2)
        x2_i = min(x2_1, x2_2)
        y2_i = min(y2_1, y2_2)
        
        if x2_i <= x1_i or y2_i <= y1_i:
            return 0.0
        
        intersection = (x2_i - x1_i) * (y2_i - y1_i)
        
        # Calculate union
        area1 = (x2_1 - x1_1) * (y2_1 - y1_1)
        area2 = (x2_2 - x1_2) * (y2_2 - y1_2)
        union = area1 + area2 - intersection
        
        return intersection / union if union > 0 else 0.0

    def _detect_runes(self, minimap):
        """Detect runes on the minimap."""
        
        try:
            # Ensure minimap is valid before processing
            if minimap is None or minimap.size == 0:
                return False, None
                
            # Ensure minimap is grayscale and uint8
            if len(minimap.shape) == 3:
                minimap = cv2.cvtColor(minimap, cv2.COLOR_BGR2GRAY)
            if minimap.dtype != np.uint8:
                minimap = minimap.astype(np.uint8)
                
            if RUNE_TEMPLATE is not None:
                try:
                    # Use multi-scale matching for better rune detection
                    rune_matches = utils.multi_scale_match(minimap, RUNE_TEMPLATE, threshold=0.6, scale_range=(0.9, 1.1), scale_steps=3)
                    if rune_matches:
                        # Use the highest confidence rune match
                        best_match = max(rune_matches, key=lambda x: x[3])
                        rune_x, rune_y, scale, confidence = best_match
                        
                        if RUNE_TEMPLATE is not None:
                            template_width = int(RUNE_TEMPLATE.shape[1] * scale)
                            template_height = int(RUNE_TEMPLATE.shape[0] * scale)
                            rune_x += template_width // 2
                            rune_y += template_height // 2
                        
                        rune_pos = utils.convert_to_relative((rune_x, rune_y), minimap)
                        # Only log when rune state changes, not every frame
                        return True, rune_pos
                    else:
                        return False, None
                except Exception as template_error:
                    print(f"[WARN] Rune template matching failed: {template_error}")
                    return False, None
            else:
                return False, None
                
        except Exception as e:
            print(f"[WARN] Rune detection failed: {e}")
            return False, None

    def _main(self):
        """Constantly monitors the player's position and in-game events."""

        while True:
            # Find MapleStory window only if we don't have it cached
            if not hasattr(self, '_cached_window_rect') or self._cached_window_rect is None:
                rect = self._find_maple_window()
                
                self.window['left'] = rect[0]
                self.window['top'] = rect[1]
                self.window['width'] = max(rect[2] - rect[0], MMT_WIDTH)
                self.window['height'] = max(rect[3] - rect[1], MMT_HEIGHT)

                print(f"[INFO] Window coordinates: {self.window}")
            else:
                # Use cached window coordinates
                rect = self._cached_window_rect
                self.window['left'] = rect[0]
                self.window['top'] = rect[1]
                self.window['width'] = max(rect[2] - rect[0], MMT_WIDTH)
                self.window['height'] = max(rect[3] - rect[1], MMT_HEIGHT)

            # Take screenshot
            with mss.mss() as self.sct:
                self.frame = self.screenshot()
            if self.frame is None:
                continue
                
            # Convert to grayscale for template matching
            if self.frame is not None and len(self.frame.shape) == 3:
                self.frame_gray = cv2.cvtColor(self.frame, cv2.COLOR_BGR2GRAY)
            else:
                self.frame_gray = self.frame
                
            # Calibrate minimap if not already calibrated
            if not self.calibrated:
                if not self._calibrate_minimap():
                    print("[WARN] Minimap calibration failed, retrying...")
                    time.sleep(1)
                    continue
                    
            # Extract minimap region with fresh screenshot
            if self.minimap_sample is not None and self.calibrated:
                # Get fresh minimap from current frame
                mm_tl = (
                    self.minimap_config['mm_left'] - self.window['left'],
                    self.minimap_config['mm_top'] - self.window['top']
                )
                mm_br = (
                    self.minimap_config['mm_right'] - self.window['left'],
                    self.minimap_config['mm_bottom'] - self.window['top']
                )
                
                # Extract fresh minimap from current frame
                minimap = self.frame[mm_tl[1]:mm_br[1], mm_tl[0]:mm_br[0]].copy()
                minimap_gray = cv2.cvtColor(minimap, cv2.COLOR_BGR2GRAY)
                
                # Debug minimap info (only print occasionally to avoid spam)
                if hasattr(self, '_debug_counter'):
                    self._debug_counter += 1
                else:
                    self._debug_counter = 0
                
                # Only print debug info every 10 seconds to avoid spam
                if self._debug_counter % 100 == 0:  # Print every 10 seconds at 10 FPS
                    print(f"[DEBUG] Fresh minimap: {minimap_gray.shape}, player_pos: {config.player_pos}")
                
                # Detect player position
                if self._detect_player(minimap_gray):
                    # Detect runes first
                    rune_active, rune_pos = self._detect_runes(minimap_gray)
                    
                    # Detect other players (excluding rune positions)
                    self._detect_others(minimap_gray, exclude_rune=rune_active and rune_pos is not None)
                    
                    # Log detection status
                    if hasattr(self, '_last_rune_state'):
                        if rune_active and not self._last_rune_state:
                            print(f"[INFO] 🎯 RUNE SPAWNED at {rune_pos}")
                        elif not rune_active and self._last_rune_state:
                            print(f"[INFO] 🎯 Rune disappeared")
                    self._last_rune_state = rune_active
                    
                    # Create debug version of minimap with detection highlights
                    debug_minimap = minimap.copy()
                    
                    # Draw all detected matches for debugging (less frequently)
                    if self.debug_mode and hasattr(self, '_debug_counter') and self._debug_counter % 200 == 0:
                        # Show all matches found (for debugging)
                        all_matches = utils.multi_scale_match(minimap_gray, PLAYER_TEMPLATE, threshold=0.3, scale_range=(0.8, 1.2), scale_steps=5)
                        for match in all_matches[:3]:  # Show top 3 matches only
                            x, y, scale, conf = match
                            color = (0, 255, 0) if conf > 0.6 else (0, 0, 255)  # Green for high confidence, red for low
                            cv2.circle(debug_minimap, (int(x), int(y)), 3, color, -1)
                            cv2.putText(debug_minimap, f"{conf:.2f}", (int(x)+5, int(y)-5), 
                                      cv2.FONT_HERSHEY_SIMPLEX, 0.3, color, 1)
                    
                    # Update minimap data with rune position for filtering
                    self.minimap = {
                        'minimap': debug_minimap,  # Debug version with highlights
                        'player_pos': config.player_pos,
                        'others_pos': config.others_pos,
                        'rune_active': rune_active,
                        'rune_pos': rune_pos,
                        'path': []
                    }
                    
                    self.ready = True
                else:
                    print("[WARN] Player detection failed")
                    self.ready = False
            else:
                print("[WARN] No minimap sample available or not calibrated")
                self.ready = False
                
            time.sleep(0.1)  # 10 FPS update rate
